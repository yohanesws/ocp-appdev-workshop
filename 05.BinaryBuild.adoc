:imagesdir: ./images
:icons: font
:toc: left

= Binary Build

== Creating OpenShift Build

We need create build for handle openshift binary build with Red Hat DotnetCore xPaaS image as builder

-----
$ oc login <OPENSHIFT_URL>
$ oc new-build openshift/dotnet:2.1 --name=binarydotnet --binary
--> Found image 1ebf90b (12 days old) in image stream "openshift/dotnet" under tag "2.1" for "openshift/dotnet:2.1"

    .NET Core 2.1 
    ------------- 
    Platform for building and running .NET Core 2.1 applications

    Tags: builder, .net, dotnet, dotnetcore, rh-dotnet21

    * A source build using binary input will be created
      * The resulting image will be pushed to image stream "binarydotnet:latest"
      * A binary build was created, use 'start-build --from-dir' to trigger a new build

--> Creating resources with label build=binarydotnet2 ...
    imagestream "binarydotnet" created
    buildconfig "binarydotnet" created
--> Success


-----

Notice what OpenShift did with our request It created  an imagestream and a buildconfig object, both named binarydotnet. The imagestream will track the new images that get built as part of this new build process, and the buildconfig contains all the instructions that tell OpenShift how to build my app.



== Start OpenShift Build

Now we can kick off my build by pointing the oc client at my local project directory. 
The command to do that is 
----
oc start-build <buildconfig-name> --from-dir=<dir-path>. 
----
Before we run it though, we want to walk through a few parameters we are going to use. First off, we know that my <buildconfig-name> will be myjavaapps and the <file-path> will be my current warfile-demo directory. 

If we run that command as-is (i.e. oc start-build mybinarydotnetjavaapps --from-dir=.) then a build will kick-off, the command will exit, and the build will run in the background. However, in this instance, I would prefer to actually follow the status of the build. To do that, we are going to add the --follow=true (follow the logs of the build) and --wait=true (wait until the build completes to return an exit code).

----
$ oc start-build binarydotnet --from-dir=.  --follow=true --wait
Uploading directory "." as binary input for the build ...
build "binarydotnet-3" started
Receiving source from STDIN as archive ...
---> Installing application source...
Using SDK: 2.1.302
---> Restoring application dependencies...
Restoring packages for /opt/app-root/src/mydotnetapps.csproj...
... 
Generating MSBuild file /opt/app-root/src/obj/mydotnetapps.csproj.nuget.g.props.
Generating MSBuild file /opt/app-root/src/obj/mydotnetapps.csproj.nuget.g.targets.
Restore completed in 42.39 sec for /opt/app-root/src/mydotnetapps.csproj.
---> Publishing application...
Microsoft (R) Build Engine version 15.7.179.62826 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.
Restore completed in 51.58 ms for /opt/app-root/src/mydotnetapps.csproj.
mydotnetapps -> /opt/app-root/src/bin/Release/netcoreapp2.1/mydotnetapps.dll
mydotnetapps -> /opt/app-root/app/
Pushing image 172.30.1.1:5000/workshop/binarydotnet:latest ...
Pushed 4/5 layers, 82% complete
Pushed 5/5 layers, 100% complete
Push successful

----

== Deploy the Application

Now that we have my application image built, we can deploy it. This is very simple. we just run the *oc new-app* command and specify my ImageStream, binarydotnet.

----
$ oc new-app binarydotnet
--> Found image f1bc290 (2 minutes old) in image stream "yohanes-demo/binarydotnet" under tag "latest" for "binarydotnet"

    yohanes-demo/binarydotnet-1:d8140b71 
    ---------------------------------- 
    Platform for building and running plain Java applications (fat-jar and flat classpath)

    Tags: builder, java

    * This image will be deployed in deployment config "myjavaapps"
    * Ports 8080/tcp, 8443/tcp, 8778/tcp will be load balanced by service "myjavaapps"
      * Other containers can access this service through the hostname "myjavaapps"

--> Creating resources ...
    deploymentconfig "binarydotnet" created
    service "binarydotnet" created
--> Success
    Application is not exposed. You can expose services to the outside world by executing one or more of the commands below:
     'oc expose svc/binarydotnet' 
    Run 'oc status' to view your app.
----


We can check the status here:

----
$ oc status
In project yohanes-demo on server https://master.rhpds.openshift.opentlc.com:443

http://cakephp-ex-yohanes-demo.apps.rhpds.openshift.opentlc.com to pod port 8080-tcp (svc/cakephp-ex)
  dc/cakephp-ex deploys istag/cakephp-ex:latest <-
    bc/cakephp-ex source builds https://github.com/openshift/cakephp-ex.git#master on openshift/php:7.0 
    deployment #2 deployed 7 hours ago - 1 pod
    deployment #1 failed 7 hours ago: newer deployment was found running

svc/binarydotnet - 172.30.12.188 ports 8080, 8443, 8778
  dc/binarydotnet deploys istag/binarydotnet:latest <-
    bc/binarydotnet source builds uploaded code on openshift/dotnet:2.1
    deployment #1 deployed 18 seconds ago - 1 pod
----

== Create Route

Now the application is already deployed then we can try to expose the service through Route using command below:

----
$ oc expose service myjavaapps
route "myjavaapps" exposed
$ oc get route
NAME         HOST/PORT                                                  PATH      SERVICES     PORT       TERMINATION   WILDCARD
cakephp-ex   cakephp-ex-yohanes-demo.apps.rhpds.openshift.opentlc.com             cakephp-ex   8080-tcp                 None
               None
binarydotnet   binarydotnet-yohanes-demo.apps.rhpds.openshift.opentlc.com             binarydotnet   8080-tcp                 None
                None
----

As we can see here, the oc expose command creates me a route with a hostname. This hostname is resolvable and accessible to me which means that we can now pull up http://binarydotnet-yohanes-demo.apps.rhpds.openshift.opentlc.com in my browser.